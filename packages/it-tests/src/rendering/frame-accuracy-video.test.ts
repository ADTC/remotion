import execa from "execa";
import fs from "fs";
import os from "os";
import path from "path";
import sharp from "sharp";
import { random } from "remotion";
import { expect, test } from "vitest";

function selectColor(color: string, frame: number) {
  return Math.floor((random(`${color}-${frame}`) * 255) % 255);
}

const getMissedFramesforCodec = async () => {
  const outputDir = await fs.promises.mkdtemp(
    path.join(os.tmpdir(), "remotion-")
  );
  const outputPath = path.join(outputDir, "vid.mp4");

  // render the Framer example to an image
  // sequence which can be checked for accuracy
  await execa(
    "pnpm",
    [
      "exec",
      "remotion",
      "render",
      "src/index.tsx",
      `framer`,
      "--log=verbose",
      outputPath,
    ],
    {
      cwd: path.join(process.cwd(), "..", "example"),
    }
  );

  await execa("ffmpeg", [
    "-i",
    outputPath,
    "-f",
    "image2",
    path.join(outputDir, "out%3d.jpeg"),
    "-y",
  ]);

  let missedFrames = 0;

  for (let frame = 0; frame < 100; frame++) {
    // each frame of the embedded video contains a (deterministically) random color which should appear correctly
    // in the rendered output
    const expectedColor = {
      red: selectColor("red", frame),
      green: selectColor("green", frame),
      blue: selectColor("blue", frame),
    };

    // extract the actual RGB color value of the top left pixel in the frame image that was generated by remotion
    const paddedIndex = String(frame + 1).padStart(3, "0");
    const filename = path.join(outputDir, `out${paddedIndex}.jpeg`);
    const img = await sharp(filename).raw().toBuffer();

    const actualColor = {
      red: img.readUInt8(1080 * 3 * 20 + 540 * 3 + 0),
      green: img.readUInt8(1080 * 3 * 20 + 540 * 3 + 1),
      blue: img.readUInt8(1080 * 3 * 20 + 540 * 3 + 2),
    };

    const colorDistance = {
      red: Math.abs(expectedColor.red - actualColor.red),
      green: Math.abs(expectedColor.green - actualColor.green),
      blue: Math.abs(expectedColor.blue - actualColor.blue),
    };

    // encoding sometimes shifts the color slightly - so measure the distance between the expected and actual
    // colors and consider any frame not within an acceptable range to be wrong
    const highestDistance = Math.max(
      colorDistance.red,
      colorDistance.blue,
      colorDistance.green
    );
    const threshold = 10;
    if (highestDistance > threshold) {
      console.log(colorDistance, {actualColor, threshold, frame, filename });
      missedFrames++;
    }
  }
  return missedFrames;
};

test("should render correct frames from embedded videos to an MP4 - MP4 offthread", async () => {
  const missedFrames = await getMissedFramesforCodec();
  expect(missedFrames).toBe(0);
});
